---
tags: vaje, kirv, hash
hackmd: https://hackmd.io/klHFG502Rt29j094sjMKqw
plugins: mathjax
---
# Cryptography and computer security - Tutorial 5.1.2021

---

## Hash functions

### Security notions

* **Preimage resistance**: given $y$, it is computationally infeasible to find an $x$ such that $H(x) = y$.
* **Second preimage resistance**: given $x$, it is computationally infeasible to find an $x' \ne x$ such that $H(x) = H(x')$.
* **Collision resistance**: it is computationally infeasible to find $x, x'$ such that $x \ne x'$ and $H(x) = H(x')$.

### Merkle-Damg√•rd construction

![](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Merkle-Damgard_hash_big.svg/400px-Merkle-Damgard_hash_big.svg.png)

---

### Exercise 1

Show that collision resistance implies second-preimage resistance of hash functions.

---

### Exercise 2

Let $g : {\lbrace 0, 1 \rbrace^*} \to \lbrace 0, 1 \rbrace^n$ be a collision resistant hash function. Consider the $(n+1)$-bit hash function $h$ defined as

$$
h(x) = \begin{cases}
1 \| x & \text{if $|x| = n$,} \\
0 \| g(x) & \text{otherwise.}
\end{cases}
$$

Show that $h$ is collision resistant, but not preimage resistant.

---

### Exercise 3

Suppose that ${H_1}, {H_2} : {\lbrace 0, 1 \rbrace^*} \to \lbrace 0, 1 \rbrace^n$ are collision resistant hash functions. Show that the function ${H_3}(x) = {H_2}({H_1}(x))$ is also collision resistant.

---

### Exercise 4

Let $H : {\lbrace 0, 1 \rbrace^*} \to \lbrace 0, 1 \rbrace^n$ be a collision resistant hash function. Which of the following are collision resistant?

1. $H'(x) = H(x) \oplus H(x)$
2. <i>$H'(x) = H(x \| 0)$</i>
3. <i>$H'(x) = H(x) \| H(0)$</i>
4. $H'(x) = H(x)[0:31]$ (i.e., the first $32$ bits of the hash)
5. $H'(x) = H(x)[0:(n-2)]$ (i.e., the hash without the last bit)
6. $H'(x) = H(H(x))$
7. $H'(x) = H(H(H(x)))$
8. $H'(x) = H(0)$
9. <i>$H'(x) = H(x) \oplus H(x \oplus 1^{|x|})$</i> (where <i>$x \oplus 1^{|x|}$</i> is the bit-complement of $x$)

---

### Exercise 5 - multicollisions in iterated hash functions

Let $H$ be an iterated hash function with compression function $f : \lbrace 0, 1 \rbrace^{n+r} \to \lbrace 0, 1 \rbrace^n$. Suppose that you are given an algorithm $A$, which on input $z \in \lbrace 0, 1 \rbrace^n$ finds $s, t \in \lbrace 0, 1 \rbrace^r$, $s \ne t$, such that $f(z, s) = f(z, t)$. Let $T$ be the running time of $A$, and let $L = 2^\ell$, where $\ell$ is a positive integer. Show how $A$ can be used to find, in time $\ell T$, a collection of $L$ pairwise distinct messages ${x_1}, {x_2}, \dots, {x_L}$ such that $H({x_1}) = H({x_2}) = \dots = H({x_L})$.

---

### Exercise 6 - multiple hash functions

Prove that the concatenation of the $\operatorname{MD5}$ and $\operatorname{SHA-1}$ hash functions yields no appreciably greater security than $\operatorname{SHA-1}$ alone. More specifically, show that a collision can be found for the hash function $H : {\lbrace 0, 1 \rbrace^*} \to \lbrace 0, 1 \rbrace^{288}$ given by

$$
H(x) = \operatorname{MD5}(x) \| \operatorname{SHA-1}(x)
$$

using roughly $C \cdot 2^{80}$ operations, for some reasonably sized constant $C$.